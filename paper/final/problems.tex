\section{Problem Examples}
At present, our system includes seven CTF challenges, with one
disabled due to missing a key file. To give a sense of the style of
problems, and expected interactions with the problems, we will now
outline two different included challenges.

\subsection{Hitcon 2014's rsaha}
This challenge runs a small server encrypting messages using RSA. The server encrypts random messages and expects the plaintext as input. After succeffully decrypting 10 numbers, the server will give out the flag, which is of course also encrypted. As with many crypto CTF problems, the challenge uses a server primarily to limit the time to decrypt a messages. For each message, the user only has a window of 10 seconds to reply with the plaintext. This prevents any simple brute-force attacks.

The provided server source code shows how the messages are encrypted. The server uses naive RSA encryption without any padding. For each message, two random primes $p$ and $q$ with increasing bitlength between 50 and 450 bits are generated. The server computes the modulus $n=p\cdot q$ from it and encrypts the message with the public exponent $e=3$: $c_1\equiv m^3 \pmod{b}$. However, the server also returns $c_2\equiv (m+1)^3\pmod{b}$. 

But this allows us to use an attack published by Franklin and Reiter \cite{franklin1995linear}, which works if we have two messages $m_1$ and $m_2$ with $m_1 +1 = m_2$ and three as the public exponent:

\[ \frac{c_2+2c_1-1}{c_2-c_1+2} = \ldots \]

\subsection{PlaidCTF 2014's parlor}

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\textwidth]{parlor_page.png}
\caption{Plaid2014 parlor challenge page}\label{fig:parlor_page}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\textwidth]{parlor_interface.png}
\caption{Plaid2014 parlor server text-based interface}\label{fig:parlor_interface}
\end{figure}


This challenge is a small server that runs a betting game. The game is
designed around guessing the last digits of a hash, which is
constructed via \texttt{md5(snonce+pnonce)}. The two nonces are from
the server (\texttt{snonce}) and the player
(\texttt{pnonce}). However, the server re-uses the server nonce until
the player asks for it to verify the server did not cheat. This
creates a situation where the server is vulnerable to a
\textit{hash-length extension} attack. When the player submits a
nonce, they get back the lower 100 bits of the resulting md5sum. By
obtaining two sample set of bits from \texttt{md5(snonce+X)} and
\texttt{md5(snonce+X+L)}, the player can brute-force the first 28 bits
of the md5sum and verify by using a hash-length extension attack
tool. From there, they can generate the $L$ value they desire to
always win the bet. After winning a (otherwise statistically
impossible) large number of bets, the server will hand back a 'flag'
as a reward.

This problem represents a very standard CTF problem design; a very
basic contained server (just a single python file) that plays an
ostensibly fair game that cannot be won fairly. Our design makes
integrating problems like this very simple. Filling out the
description and hints is straight forward, while the suggested reading
had to be careful not to only include links to hash-length extension
attacks. The server configuration is mostly handled by the templated
init script that the new problem generation tool will use. The problem
designer needs only fill out two lines of a configuration file (with
the problem name and server binary), and write any description and
solution information they wish to include.
